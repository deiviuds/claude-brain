{"version":3,"sources":["../../src/utils/helpers.ts","../../src/utils/memvid-lock.ts","../../src/utils/session.ts","../../src/hooks/session-start.ts"],"names":["resolve","mkdir","dirname"],"mappings":"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","file":"session-start.js","sourcesContent":["/**\n * Memvid Mind - Utility Helpers\n */\n\nimport { randomBytes } from \"node:crypto\";\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return randomBytes(8).toString(\"hex\");\n}\n\n/**\n * Estimate token count for text (rough approximation)\n * ~4 characters per token for English text\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n\n/**\n * Truncate text to fit within token limit\n */\nexport function truncateToTokens(text: string, maxTokens: number): string {\n  const maxChars = maxTokens * 4;\n  if (text.length <= maxChars) return text;\n  return text.slice(0, maxChars - 3) + \"...\";\n}\n\n/**\n * Format timestamp to human-readable string\n */\nexport function formatTimestamp(ts: number): string {\n  const date = new Date(ts);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMs / 3600000);\n  const diffDays = Math.floor(diffMs / 86400000);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString();\n}\n\n/**\n * Parse JSON safely\n */\nexport function safeJsonParse<T>(text: string, fallback: T): T {\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return fallback;\n  }\n}\n\n/**\n * Read all stdin as string\n */\nexport async function readStdin(): Promise<string> {\n  const chunks: Buffer[] = [];\n\n  return new Promise((resolve, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\n\n/**\n * Write JSON to stdout and exit immediately\n * (Prevents SDK background tasks from blocking process exit)\n */\nexport function writeOutput(output: unknown): never {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\n\n/**\n * Log debug message to stderr\n */\nexport function debug(message: string): void {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\n\n/**\n * Extract key information from tool output\n */\nexport function extractKeyInfo(toolName: string, output: string): string {\n  // Truncate very long outputs\n  const maxLength = 2000;\n  const truncated = output.length > maxLength\n    ? output.slice(0, maxLength) + \"\\n... (truncated)\"\n    : output;\n\n  // Tool-specific extraction\n  switch (toolName) {\n    case \"Read\":\n      // Extract file summary from read output\n      return extractFileReadSummary(truncated);\n    case \"Bash\":\n      // Extract command summary\n      return extractBashSummary(truncated);\n    case \"Edit\":\n      // Extract edit summary\n      return extractEditSummary(truncated);\n    case \"Grep\":\n    case \"Glob\":\n      // Extract search summary\n      return extractSearchSummary(truncated);\n    default:\n      return truncated;\n  }\n}\n\nfunction extractFileReadSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 20) return output;\n  return `${lines.slice(0, 10).join(\"\\n\")}\\n... (${lines.length} lines total)`;\n}\n\nfunction extractBashSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 30) return output;\n  return [\n    ...lines.slice(0, 10),\n    `... (${lines.length - 20} lines omitted)`,\n    ...lines.slice(-10),\n  ].join(\"\\n\");\n}\n\nfunction extractEditSummary(output: string): string {\n  // Edits are usually compact, return as-is\n  return output;\n}\n\nfunction extractSearchSummary(output: string): string {\n  const lines = output.split(\"\\n\").filter(Boolean);\n  if (lines.length <= 20) return output;\n  return [\n    ...lines.slice(0, 15),\n    `... and ${lines.length - 15} more results`,\n  ].join(\"\\n\");\n}\n\n/**\n * Classify observation type from tool and output\n */\nexport function classifyObservationType(\n  toolName: string,\n  output: string\n): \"discovery\" | \"decision\" | \"problem\" | \"solution\" | \"pattern\" | \"warning\" | \"success\" | \"refactor\" | \"bugfix\" | \"feature\" {\n  const lowerOutput = output.toLowerCase();\n\n  // Error detection\n  if (\n    lowerOutput.includes(\"error\") ||\n    lowerOutput.includes(\"failed\") ||\n    lowerOutput.includes(\"exception\")\n  ) {\n    return \"problem\";\n  }\n\n  // Success detection\n  if (\n    lowerOutput.includes(\"success\") ||\n    lowerOutput.includes(\"passed\") ||\n    lowerOutput.includes(\"completed\")\n  ) {\n    return \"success\";\n  }\n\n  // Warning detection\n  if (lowerOutput.includes(\"warning\") || lowerOutput.includes(\"deprecated\")) {\n    return \"warning\";\n  }\n\n  // Tool-based classification\n  switch (toolName) {\n    case \"Read\":\n    case \"Glob\":\n    case \"Grep\":\n      return \"discovery\";\n    case \"Edit\":\n      if (lowerOutput.includes(\"fix\") || lowerOutput.includes(\"bug\")) {\n        return \"bugfix\";\n      }\n      return \"refactor\";\n    case \"Write\":\n      return \"feature\";\n    default:\n      return \"discovery\";\n  }\n}\n","import lockfile from \"proper-lockfile\";\nimport { mkdir, open } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\n\nconst LOCK_OPTIONS = {\n  stale: 30000,\n  retries: {\n    retries: 1000,\n    minTimeout: 5,\n    maxTimeout: 50,\n  },\n} as const;\n\nexport async function withMemvidLock<T>(\n  lockPath: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  await mkdir(dirname(lockPath), { recursive: true });\n  const handle = await open(lockPath, \"a\");\n  await handle.close();\n\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\n  try {\n    return await fn();\n  } finally {\n    await release();\n  }\n}\n","/**\n * Memvid Mind - Session Management\n *\n * Provides persistent session ID tracking across hook invocations.\n * Works with opencode-brain for cross-tool compatibility.\n */\n\nimport { readFile, writeFile, mkdir } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport { withMemvidLock } from \"./memvid-lock.js\";\n\nexport interface SessionInfo {\n  sessionId: string;\n  source: \"opencode\" | \"claude-code\" | \"unknown\";\n  startTime: number;\n}\n\n/**\n * Get session file path for a specific source\n */\nfunction getSessionPath(directory: string, source: string): string {\n  return `${directory}/.claude/mind-session-${source}.json`;\n}\n\n/**\n * Detect which tool we're running under\n */\nexport function detectSource(): \"opencode\" | \"claude-code\" | \"unknown\" {\n  // OpenCode sets OPENCODE_SESSION_ID or similar\n  if (process.env.OPENCODE_SESSION_ID) return \"opencode\";\n  if (process.env.OPENCODE_DIR) return \"opencode\";\n  // Claude Code sets CLAUDE_PROJECT_DIR\n  if (process.env.CLAUDE_PROJECT_DIR && !process.env.OPENCODE_SESSION_ID) return \"claude-code\";\n  // Default to claude-code for this plugin\n  return \"claude-code\";\n}\n\n/**\n * Write session info (called at session start)\n */\nexport async function writeSessionInfo(\n  directory: string,\n  sessionId: string,\n  source: \"opencode\" | \"claude-code\" | \"unknown\"\n): Promise<void> {\n  const sessionPath = getSessionPath(directory, source);\n  const lockPath = `${sessionPath}.lock`;\n\n  await mkdir(dirname(sessionPath), { recursive: true });\n\n  await withMemvidLock(lockPath, async () => {\n    const info: SessionInfo = {\n      sessionId,\n      source,\n      startTime: Date.now(),\n    };\n    await writeFile(sessionPath, JSON.stringify(info));\n  });\n}\n\n/**\n * Read session info (called by tool hooks)\n */\nexport async function readSessionInfo(\n  directory: string,\n  source: \"opencode\" | \"claude-code\" | \"unknown\"\n): Promise<SessionInfo | null> {\n  const sessionPath = getSessionPath(directory, source);\n\n  try {\n    const content = await readFile(sessionPath, \"utf8\");\n    return JSON.parse(content);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get or create session ID for current context\n */\nexport async function getSessionId(\n  directory: string,\n  fallbackId?: string\n): Promise<string> {\n  const source = detectSource();\n  const info = await readSessionInfo(directory, source);\n\n  if (info?.sessionId) {\n    return info.sessionId;\n  }\n\n  // Return fallback or generate new\n  return fallbackId || `${source}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n}\n","#!/usr/bin/env node\n/**\n * Memvid Mind - Session Start Hook\n *\n * LIGHTWEIGHT startup - does NOT load the SDK.\n * SDK is loaded lazily on first tool use instead.\n * This keeps Claude startup fast (< 1 second).\n */\n\nimport { readStdin, writeOutput, debug } from \"../utils/helpers.js\";\nimport { writeSessionInfo, detectSource } from \"../utils/session.js\";\nimport type { HookInput } from \"../types.js\";\nimport { existsSync, statSync } from \"node:fs\";\nimport { resolve, basename } from \"node:path\";\n\nasync function main() {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    debug(`Session starting: ${hookInput.session_id}`);\n\n    // Get project info\n    const projectDir = hookInput.cwd || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n\n    // Write session info for cross-process session tracking\n    const source = detectSource();\n    try {\n      await writeSessionInfo(projectDir, hookInput.session_id, source);\n      debug(`Session info written: ${hookInput.session_id} (${source})`);\n    } catch (err) {\n      debug(`Failed to write session info: ${err}`);\n    }\n\n    const projectName = basename(projectDir);\n    const memoryPath = resolve(projectDir, \".claude/mind.mv2\");\n\n    // Quick check if memory file exists (no SDK needed)\n    const memoryExists = existsSync(memoryPath);\n\n    // Build minimal context without loading SDK\n    const contextLines: string[] = [];\n\n    if (memoryExists) {\n      try {\n        const stats = statSync(memoryPath);\n        const fileSizeKB = Math.round(stats.size / 1024);\n\n        contextLines.push(\"<memvid-mind-context>\");\n        contextLines.push(\"# üß† Claude Mind Active\");\n        contextLines.push(\"\");\n        contextLines.push(`üìÅ Project: **${projectName}**`);\n        contextLines.push(`üíæ Memory: \\`.claude/mind.mv2\\` (${fileSizeKB} KB)`);\n        contextLines.push(\"\");\n        contextLines.push(\"**Commands:**\");\n        contextLines.push(\"- `/mind:search <query>` - Search memories\");\n        contextLines.push(\"- `/mind:ask <question>` - Ask your memory\");\n        contextLines.push(\"- `/mind:recent` - View timeline\");\n        contextLines.push(\"- `/mind:stats` - View statistics\");\n        contextLines.push(\"\");\n        contextLines.push(\"_Memories are captured automatically from your tool use._\");\n        contextLines.push(\"</memvid-mind-context>\");\n      } catch {\n        // Ignore stat errors\n      }\n    } else {\n      // First time - memory will be created on first observation\n      contextLines.push(\"<memvid-mind-context>\");\n      contextLines.push(\"# üß† Claude Mind Ready\");\n      contextLines.push(\"\");\n      contextLines.push(`üìÅ Project: **${projectName}**`);\n      contextLines.push(\"üíæ Memory will be created at: \\`.claude/mind.mv2\\`\");\n      contextLines.push(\"\");\n      contextLines.push(\"_Your observations will be automatically captured._\");\n      contextLines.push(\"</memvid-mind-context>\");\n    }\n\n    // SessionStart hooks use hookSpecificOutput.additionalContext\n    const output: any = {\n      continue: true,\n    };\n\n    if (contextLines.length > 0) {\n      output.hookSpecificOutput = {\n        hookEventName: \"SessionStart\",\n        additionalContext: contextLines.join(\"\\n\"),\n      };\n    }\n\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\nmain();\n"]}