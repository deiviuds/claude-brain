{"version":3,"sources":["../../src/utils/helpers.ts","../../src/hooks/session-start.ts"],"names":["resolve"],"mappings":"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","file":"session-start.js","sourcesContent":["/**\n * Memvid Mind - Utility Helpers\n */\n\nimport { randomBytes } from \"node:crypto\";\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return randomBytes(8).toString(\"hex\");\n}\n\n/**\n * Estimate token count for text (rough approximation)\n * ~4 characters per token for English text\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n\n/**\n * Truncate text to fit within token limit\n */\nexport function truncateToTokens(text: string, maxTokens: number): string {\n  const maxChars = maxTokens * 4;\n  if (text.length <= maxChars) return text;\n  return text.slice(0, maxChars - 3) + \"...\";\n}\n\n/**\n * Format timestamp to human-readable string\n */\nexport function formatTimestamp(ts: number): string {\n  const date = new Date(ts);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMs / 3600000);\n  const diffDays = Math.floor(diffMs / 86400000);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString();\n}\n\n/**\n * Parse JSON safely\n */\nexport function safeJsonParse<T>(text: string, fallback: T): T {\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return fallback;\n  }\n}\n\n/**\n * Read all stdin as string\n */\nexport async function readStdin(): Promise<string> {\n  const chunks: Buffer[] = [];\n\n  return new Promise((resolve, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\n\n/**\n * Write JSON to stdout and exit immediately\n * (Prevents SDK background tasks from blocking process exit)\n */\nexport function writeOutput(output: unknown): never {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\n\n/**\n * Log debug message to stderr\n */\nexport function debug(message: string): void {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\n\n/**\n * Extract key information from tool output\n */\nexport function extractKeyInfo(toolName: string, output: string): string {\n  // Truncate very long outputs\n  const maxLength = 2000;\n  const truncated = output.length > maxLength\n    ? output.slice(0, maxLength) + \"\\n... (truncated)\"\n    : output;\n\n  // Tool-specific extraction\n  switch (toolName) {\n    case \"Read\":\n      // Extract file summary from read output\n      return extractFileReadSummary(truncated);\n    case \"Bash\":\n      // Extract command summary\n      return extractBashSummary(truncated);\n    case \"Edit\":\n      // Extract edit summary\n      return extractEditSummary(truncated);\n    case \"Grep\":\n    case \"Glob\":\n      // Extract search summary\n      return extractSearchSummary(truncated);\n    default:\n      return truncated;\n  }\n}\n\nfunction extractFileReadSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 20) return output;\n  return `${lines.slice(0, 10).join(\"\\n\")}\\n... (${lines.length} lines total)`;\n}\n\nfunction extractBashSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 30) return output;\n  return [\n    ...lines.slice(0, 10),\n    `... (${lines.length - 20} lines omitted)`,\n    ...lines.slice(-10),\n  ].join(\"\\n\");\n}\n\nfunction extractEditSummary(output: string): string {\n  // Edits are usually compact, return as-is\n  return output;\n}\n\nfunction extractSearchSummary(output: string): string {\n  const lines = output.split(\"\\n\").filter(Boolean);\n  if (lines.length <= 20) return output;\n  return [\n    ...lines.slice(0, 15),\n    `... and ${lines.length - 15} more results`,\n  ].join(\"\\n\");\n}\n\n/**\n * Classify observation type from tool and output\n */\nexport function classifyObservationType(\n  toolName: string,\n  output: string\n): \"discovery\" | \"decision\" | \"problem\" | \"solution\" | \"pattern\" | \"warning\" | \"success\" | \"refactor\" | \"bugfix\" | \"feature\" {\n  const lowerOutput = output.toLowerCase();\n\n  // Error detection\n  if (\n    lowerOutput.includes(\"error\") ||\n    lowerOutput.includes(\"failed\") ||\n    lowerOutput.includes(\"exception\")\n  ) {\n    return \"problem\";\n  }\n\n  // Success detection\n  if (\n    lowerOutput.includes(\"success\") ||\n    lowerOutput.includes(\"passed\") ||\n    lowerOutput.includes(\"completed\")\n  ) {\n    return \"success\";\n  }\n\n  // Warning detection\n  if (lowerOutput.includes(\"warning\") || lowerOutput.includes(\"deprecated\")) {\n    return \"warning\";\n  }\n\n  // Tool-based classification\n  switch (toolName) {\n    case \"Read\":\n    case \"Glob\":\n    case \"Grep\":\n      return \"discovery\";\n    case \"Edit\":\n      if (lowerOutput.includes(\"fix\") || lowerOutput.includes(\"bug\")) {\n        return \"bugfix\";\n      }\n      return \"refactor\";\n    case \"Write\":\n      return \"feature\";\n    default:\n      return \"discovery\";\n  }\n}\n","#!/usr/bin/env node\n/**\n * Memvid Mind - Session Start Hook\n *\n * LIGHTWEIGHT startup - does NOT load the SDK.\n * SDK is loaded lazily on first tool use instead.\n * This keeps Claude startup fast (< 1 second).\n */\n\nimport { readStdin, writeOutput, debug } from \"../utils/helpers.js\";\nimport type { HookInput } from \"../types.js\";\nimport { existsSync, statSync } from \"node:fs\";\nimport { resolve, basename } from \"node:path\";\n\nasync function main() {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    debug(`Session starting: ${hookInput.session_id}`);\n\n    // Get project info without loading SDK\n    const projectDir = hookInput.cwd || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const projectName = basename(projectDir);\n    const memoryPath = resolve(projectDir, \".claude/mind.mv2\");\n\n    // Quick check if memory file exists (no SDK needed)\n    const memoryExists = existsSync(memoryPath);\n\n    // Build minimal context without loading SDK\n    const contextLines: string[] = [];\n\n    if (memoryExists) {\n      try {\n        const stats = statSync(memoryPath);\n        const fileSizeKB = Math.round(stats.size / 1024);\n\n        contextLines.push(\"<memvid-mind-context>\");\n        contextLines.push(\"# üß† Claude Mind Active\");\n        contextLines.push(\"\");\n        contextLines.push(`üìÅ Project: **${projectName}**`);\n        contextLines.push(`üíæ Memory: \\`.claude/mind.mv2\\` (${fileSizeKB} KB)`);\n        contextLines.push(\"\");\n        contextLines.push(\"**Commands:**\");\n        contextLines.push(\"- `/mind:search <query>` - Search memories\");\n        contextLines.push(\"- `/mind:ask <question>` - Ask your memory\");\n        contextLines.push(\"- `/mind:recent` - View timeline\");\n        contextLines.push(\"- `/mind:stats` - View statistics\");\n        contextLines.push(\"\");\n        contextLines.push(\"_Memories are captured automatically from your tool use._\");\n        contextLines.push(\"</memvid-mind-context>\");\n      } catch {\n        // Ignore stat errors\n      }\n    } else {\n      // First time - memory will be created on first observation\n      contextLines.push(\"<memvid-mind-context>\");\n      contextLines.push(\"# üß† Claude Mind Ready\");\n      contextLines.push(\"\");\n      contextLines.push(`üìÅ Project: **${projectName}**`);\n      contextLines.push(\"üíæ Memory will be created at: \\`.claude/mind.mv2\\`\");\n      contextLines.push(\"\");\n      contextLines.push(\"_Your observations will be automatically captured._\");\n      contextLines.push(\"</memvid-mind-context>\");\n    }\n\n    // SessionStart hooks use hookSpecificOutput.additionalContext\n    const output: any = {\n      continue: true,\n    };\n\n    if (contextLines.length > 0) {\n      output.hookSpecificOutput = {\n        hookEventName: \"SessionStart\",\n        additionalContext: contextLines.join(\"\\n\"),\n      };\n    }\n\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\nmain();\n"]}